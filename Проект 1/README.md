# Инкрементальное обновление данных в витрине
Цель проекта было создание витрины и реализация инкрементального обновления данных.
![Image alt](https://github.com/George70164/Yandex_Practicum_DE/blob/main/%D0%9F%D1%80%D0%BE%D0%B5%D0%BA%D1%82%201/png/%D1%81%D1%85%D0%B5%D0%BC%D0%B0.png)
## Шаги

- Создать дополнительную таблицу
- Выбрать из хранилища только изменённые или новые данные
- Определить, какие данные из дельты нужно обновить
- Выполнить расчёт витрины только для данных, которые нужно вставить
- Выполнить расчёт витрины для данных, которые нужно обновить
- Выполнить вставку новых данных в витрину
- Выполнить обновление изменённых данных в витрине
- Выполнить вставку максимальной даты загрузки из дельты в дополнительную таблицу

## Шаг 1 (Создать дополнительную таблицу)
В дополнительной таблице — две основные колонки: id записи, дата и время загрузки новых данных. Дата и время загрузки будут определяться как максимальное время из всего, что было загружено в хранилище. На основе даты будет приниматься решение о том, какие данные были изменены или добавлены.

## Шаг 2 (Выбрать из хранилища только изменённые или новые данные)
Чтобы определить, какие данные были изменены или добавлены, были добавлены в запрос следующее условие: дата загрузки данных в DWH должна быть старше даты из дополнительной таблицы. Выборка из новых или изменённых данных - это дельта.

## Шаг 3 (Определить, какие данные из дельты нужно обновить)[(Проект 1/Шаг 3 спринт 2.sql)](https://github.com/George70164/Yandex_Practicum_DE/blob/main/%D0%9F%D1%80%D0%BE%D0%B5%D0%BA%D1%82%201/%D0%A8%D0%B0%D0%B3%203%20%D1%81%D0%BF%D1%80%D0%B8%D0%BD%D1%82%202.sql)
Части данных в витрине раньше не было, поэтому их нужно вставить с помощью INSERT, а другая часть уже была — их значения нужно обновить с помощью UPDATE. Стоит отметить, что в классическом случае исторические данные в витрине не обновляются и инкременты добавляются независимо друг от друга, даже если появилась новая информация о старых фактах. Для решения задачи важен факт изменения исторических данных и их влияние на витрину независимо от периода расчёта, так как это может затронуть решения бизнеса. Поэтому текущая реализация будет немного отличаться от классической инкрементальной загрузки с учётом обновления исторических данных. Такой подход можно назвать MERGE REFRESH.

## Шаг 4 (Выполнить расчёт витрины только для данных, которые нужно вставить)
В ```dwh_update_delta``` находятся ```craftsman_id```, которые нужно обновить. А те данные, что нужно добавить, — в блоке ```dwh_delta``` с ```exist_craftsman_id is NULL```.

## Шаг 5 (Выполнить расчёт витрины для данных, которые нужно обновить)
Расчёт витрины для данных обновления похож на расчёт витрины для данных вставки, есть лишь один нюанс: для начала нужно получить конкретные данные по колонкам, которые нужно пересчитать вместе с новыми данными. Для существующих в хранилище мастеров ручной работы появились новые данные по их заработку, продаже и прочим атрибутам, и теперь нужно обновить для них итоговый отчёт.

## Шаг 6 (Выполнить вставку новых данных в витрину)
Была получена выборка, которую нужно вставить в блоке ```dwh_delta_insert_result```. Осталось вставить новые данные в витрину. Для этого используйте конструкцию ```INSERT FROM SELECT```. Аргументами для ```INSERT``` будет выборка ```SELECT``` из таблицы.

## Шаг 7 (Выполнить обновление изменённых данных в витрине)
Была получена выборка, которую нужно обновить в блоке ```dwh_delta_update_result```. Осталось воспользоваться конструкцией ```UPDATE FROM SELECT```. Эта конструкция тоже предполагает, что аргументами для ```UPDATE``` будет выборка ```SELECT``` из таблицы.

## Шаг 8 (Выполнить вставку максимальной даты загрузки из дельты в дополнительную таблицу)
При вставке максимальной даты загрузки из дельты, во время следующей загрузки данных в витрину запрос на получение дельты будет учитывать только вновь добавленные или изменённые данные с более поздней датой загрузки.
В предыдущих заданиях вы обновили витрину. Чтобы в следующий раз снова посчитать именно дельту, а не все значения из хранилища, вам нужно добавить информацию о дате последнего обновления в таблицу загрузок.
